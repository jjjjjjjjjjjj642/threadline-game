<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Chaos Cooking 3D</title>
<style>
body { margin:0; overflow:hidden; background:black; }
#hud {
  position:absolute;
  top:10px; left:10px;
  color:white;
  font-family:Arial;
  background:rgba(0,0,0,.7);
  padding:10px;
}
#inventory {
  position:absolute;
  bottom:10px; left:10px;
  background:rgba(0,0,0,.7);
  padding:10px;
  color:white;
}
#alert {
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  font-size:40px;
  color:red;
  display:none;
}
</style>
</head>
<body>

<div id="hud">
Money: $<span id="money">0</span><br>
Held: <span id="held">Nothing</span><br>
Chaos: <span id="chaos">OFF</span>
</div>

<div id="inventory">
Inventory:
<ul id="invList"></ul>
</div>

<div id="alert">POLICE ARRIVED ðŸš¨</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

<script>
// ================= BASIC SETUP =================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,3,12);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,.7));
const sun = new THREE.DirectionalLight(0xffffff,1);
sun.position.set(10,20,10);
scene.add(sun);

// ================= FLOOR =================
const floor = new THREE.Mesh(
  new THREE.BoxGeometry(40,1,40),
  new THREE.MeshStandardMaterial({color:0x555555})
);
floor.position.y=-0.5;
scene.add(floor);

// ================= GAME DATA =================
let money = 0;
let held = null;
let inventory = {};
let chaos = false;

// ================= INVENTORY =================
function updateInventory(){
  const list = document.getElementById("invList");
  list.innerHTML="";
  for(const k in inventory){
    const li=document.createElement("li");
    li.innerText=`${k}: ${inventory[k]}`;
    list.appendChild(li);
  }
}

// ================= COUNTERS + INGREDIENTS =================
const items=[];
function ingredient(x,z,name,color){
  const i = new THREE.Mesh(
    new THREE.BoxGeometry(.7,.7,.7),
    new THREE.MeshStandardMaterial({color})
  );
  i.position.set(x,1,z);
  i.type="ingredient";
  i.name=name;
  scene.add(i);
  items.push(i);
}
ingredient(-5,-5,"Meat",0xff4444);
ingredient(5,-5,"Bread",0xffcc66);

// ================= CUSTOMERS =================
const customers=[];
const recipes=["Meat","Bread"];

function customer(x,z){
  const c = new THREE.Mesh(
    new THREE.BoxGeometry(1,2,1),
    new THREE.MeshStandardMaterial({color:0x00ff00})
  );
  c.position.set(x,1,z);
  c.order=recipes[Math.floor(Math.random()*recipes.length)];
  c.timer=15;
  c.angry=false;
  scene.add(c);
  customers.push(c);
}
customer(0,0);

// ================= COOKING TIMER =================
setInterval(()=>{
  customers.forEach(c=>{
    c.timer--;
    if(c.timer<=5){
      c.material.color.set(0xff8800);
      c.angry=true;
    }
    if(c.timer<=0){
      c.material.color.set(0xff0000);
      chaos=true;
      document.getElementById("chaos").innerText="ON";
    }
  });
},1000);

// ================= POLICE / CHAOS MODE =================
setInterval(()=>{
  if(chaos){
    document.getElementById("alert").style.display="block";
    scene.background=new THREE.Color(0x440000);
  }
},3000);

// ================= CONTROLS =================
let keys={},yaw=0;
document.addEventListener("keydown",e=>keys[e.code]=true);
document.addEventListener("keyup",e=>keys[e.code]=false);
document.body.onclick=()=>document.body.requestPointerLock();
document.addEventListener("mousemove",e=>{
  if(document.pointerLockElement){
    yaw-=e.movementX*0.002;
    camera.rotation.y=yaw;
  }
});

// ================= INTERACTION =================
const ray=new THREE.Raycaster();
const mouse=new THREE.Vector2();

window.addEventListener("mousedown",e=>{
  mouse.x=(e.clientX/innerWidth)*2-1;
  mouse.y=-(e.clientY/innerHeight)*2+1;
  ray.setFromCamera(mouse,camera);

  const hit=ray.intersectObjects(scene.children,true)[0];
  if(!hit) return;

  const o=hit.object;

  if(o.type==="ingredient"){
    inventory[o.name]=(inventory[o.name]||0)+1;
    o.visible=false;
    updateInventory();
  }

  customers.forEach(c=>{
    if(camera.position.distanceTo(c.position)<3 && inventory[c.order]){
      inventory[c.order]--;
      money+=10;
      document.getElementById("money").innerText=money;
      updateInventory();
      c.timer=15;
      c.material.color.set(0x00ff00);
      chaos=false;
      document.getElementById("chaos").innerText="OFF";
    }
  });
});

// ================= MOVEMENT =================
function animate(){
  requestAnimationFrame(animate);
  const v=new THREE.Vector3();
  if(keys.KeyW)v.z-=.2;
  if(keys.KeyS)v.z+=.2;
  if(keys.KeyA)v.x-=.2;
  if(keys.KeyD)v.x+=.2;
  v.applyAxisAngle(new THREE.Vector3(0,1,0),yaw);
  camera.position.add(v);
  renderer.render(scene,camera);
}
animate();

// ================= MULTIPLAYER (WEBRTC) =================
const peer = new Peer();
peer.on("open",id=>{
  console.log("Your Multiplayer ID:",id);
  alert("Multiplayer ID:\n"+id+"\nShare to connect!");
});
peer.on("connection",conn=>{
  conn.on("data",data=>{
    camera.position.fromArray(data);
  });
});
setInterval(()=>{
  if(peer.connections){
    for(const id in peer.connections){
      peer.connections[id][0].send(camera.position.toArray());
    }
  }
},100);

// ================= RESIZE =================
onresize=()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
};
</script>
</body>
<script>
// ================= SAVE SYSTEM =================
function saveGame(){
  localStorage.setItem("save", JSON.stringify({
    money,
    inventory,
    chaos
  }));
}

function loadGame(){
  const s = JSON.parse(localStorage.getItem("save"));
  if(!s) return;
  money = s.money || 0;
  inventory = s.inventory || {};
  chaos = s.chaos || false;
  document.getElementById("money").innerText = money;
  updateInventory();
}
loadGame();
setInterval(saveGame,3000);

// ================= WEAPON =================
let hasWeapon = false;

const pan = new THREE.Mesh(
  new THREE.BoxGeometry(1,.1,1),
  new THREE.MeshStandardMaterial({color:0x999999})
);
pan.position.set(3,1,-3);
pan.type="weapon";
scene.add(pan);

// ================= POLICE NPC =================
const police = [];
function spawnPolice(){
  const p = new THREE.Mesh(
    new THREE.BoxGeometry(1,2,1),
    new THREE.MeshStandardMaterial({color:0x0000ff})
  );
  p.position.set(10,1,10);
  p.speed = 0.03;
  p.stunned = 0;
  scene.add(p);
  police.push(p);
}

setInterval(()=>{
  if(chaos && police.length < 2){
    spawnPolice();
  }
},4000);

// ================= ESCAPE ZONE =================
const escape = new THREE.Mesh(
  new THREE.BoxGeometry(3,0.2,3),
  new THREE.MeshStandardMaterial({color:0x00ffff})
);
escape.position.set(-15,0,-15);
scene.add(escape);

// ================= INTERACTION EXTENSION =================
window.addEventListener("mousedown",e=>{
  mouse.x=(e.clientX/innerWidth)*2-1;
  mouse.y=-(e.clientY/innerHeight)*2+1;
  ray.setFromCamera(mouse,camera);

  const hit = ray.intersectObjects(scene.children,true)[0];
  if(!hit) return;

  const o = hit.object;

  // PICK WEAPON
  if(o.type==="weapon"){
    hasWeapon = true;
    o.visible = false;
    alert("You picked up a PAN ðŸ”¥");
  }

  // ATTACK POLICE
  if(hasWeapon){
    police.forEach(p=>{
      if(camera.position.distanceTo(p.position)<3){
        p.stunned = 200;
      }
    });
  }
});

// ================= POLICE AI =================
function updatePolice(){
  police.forEach(p=>{
    if(p.stunned > 0){
      p.stunned--;
      return;
    }

    const dir = camera.position.clone().sub(p.position).normalize();
    p.position.add(dir.multiplyScalar(p.speed));

    if(camera.position.distanceTo(p.position)<1.5){
      alert("ðŸš¨ YOU GOT CAUGHT!");
      chaos=false;
      document.getElementById("chaos").innerText="OFF";
      p.position.set(10,1,10);
    }
  });
}

// ================= ESCAPE CHECK =================
function checkEscape(){
  if(camera.position.distanceTo(escape.position)<2){
    chaos=false;
    police.forEach(p=>p.position.set(10,1,10));
    document.getElementById("chaos").innerText="OFF";
    alert("You escaped ðŸ˜ˆ");
  }
}

// ================= MULTIPLAYER SYNC EXTENSION =================
setInterval(()=>{
  if(peer && peer.connections){
    for(const id in peer.connections){
      peer.connections[id][0].send({
        pos: camera.position.toArray(),
        chaos,
        police: police.map(p=>p.position.toArray())
      });
    }
  }
},100);

peer.on("connection",conn=>{
  conn.on("data",data=>{
    if(data.pos){
      camera.position.fromArray(data.pos);
    }
    chaos = data.chaos;
    if(data.police){
      data.police.forEach((pp,i)=>{
        if(police[i]) police[i].position.fromArray(pp);
      });
    }
  });
});

// ================= UPDATE LOOP EXTENSION =================
const oldAnimate = animate;
animate = function(){
  requestAnimationFrame(animate);
  updatePolice();
  checkEscape();
  renderer.render(scene,camera);
};
</script>

